{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyWarm A cleaner way to build neural networks for PyTorch. | Examples | Tutorial | API reference | Introduction PyWarm is a high-level neural network construction API for PyTorch. It only aims to simplify the network definition, and does not cover model training, validation and data handling. With PyWarm, you can put all network data flow logic in the forward() method of your model, without the need to define children modules in the __init__() method. This result in a much more readable model definition in fewer lines of code. For example, a convnet for MNIST: (If needed, click the tabs to switch between Warm and Torch versions) Warm 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # powered by PyWarm import torch.nn as nn import torch.nn.functional as F import warm import warm.functional as W class ConvNet ( nn . Module ): def __init__ ( self ): super () . __init__ () warm . engine . prepare_model_ ( self , [ 1 , 1 , 28 , 28 ]) def forward ( self , x ): x = W . conv ( x , 20 , 5 , activation = 'relu' ) x = F . max_pool2d ( x , 2 ) x = W . conv ( x , 50 , 5 , activation = 'relu' ) x = F . max_pool2d ( x , 2 ) x = x . view ( - 1 , 800 ) x = W . linear ( x , 500 , activation = 'relu' ) x = W . linear ( x , 10 ) return F . log_softmax ( x , dim = 1 ) Torch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # vanilla PyTorch version, taken from # pytorch tutorials/beginner_source/blitz/neural_networks_tutorial.py import torch.nn as nn import torch.nn.functional as F class ConvNet ( nn . Module ): def __init__ ( self ): super () . __init__ () self . conv1 = nn . Conv2d ( 1 , 20 , 5 , 1 ) self . conv2 = nn . Conv2d ( 20 , 50 , 5 , 1 ) self . fc1 = nn . Linear ( 4 * 4 * 50 , 500 ) self . fc2 = nn . Linear ( 500 , 10 ) def forward ( self , x ): x = F . relu ( self . conv1 ( x )) x = F . max_pool2d ( x , 2 , 2 ) x = F . relu ( self . conv2 ( x )) x = F . max_pool2d ( x , 2 , 2 ) x = x . view ( - 1 , 4 * 4 * 50 ) x = F . relu ( self . fc1 ( x )) x = self . fc2 ( x ) return F . log_softmax ( x , dim = 1 ) A couple of things you may have noticed: First of all, in the PyWarm version, the entire network definition and data flow logic resides in the forward() method. You don't have to look up and down repeatedly to understand what self.conv1 , self.fc1 etc. is doing. You do not need to track and specify in_channels (or in_features , etc.) for network layers. PyWarm can infer the information for you. e.g. # Warm x = W . conv ( x , 20 , 5 , activation = 'relu' ) x = W . conv ( x , 50 , 5 , activation = 'relu' ) # Torch self . conv1 = nn . Conv2d ( 1 , 20 , 5 , 1 ) self . conv2 = nn . Conv2d ( 20 , 50 , 5 , 1 ) One unified W.conv for all 1D, 2D, and 3D cases. Fewer things to keep track of! For deeper neural networks, see additional examples . Installation pip3 install pywarm Quick start: 30 seconds to PyWarm If you already have experinces with PyTorch, using PyWarm is very straightforward: First, import PyWarm in you model file: import warm import warm.functional as W Second, delete child module definitions in the model's __init__() method. In stead, use W.conv , W.linear ... etc. in the model's forward() method, just like how you would use torch nn functional F.max_pool2d , F.relu ... etc. For example, instead of writing: # Torch class MyModule ( nn . Module ): def __init__ ( self ): super () . __init__ () self . conv1 = nn . Conv2d ( in_channels , out_channels , kernel_size ) # more child module definitions def forward ( self , x ): x = self . conv1 ( x ) # more forward steps You can now write in the warm way: # Warm class MyWarmModule ( nn . Module ): def __init__ ( self ): super () . __init__ () warm . engine . prepare_model_ ( self , input_shape_or_data ) def forward ( self , x ): x = W . conv ( x , out_channels , kernel_size ) # no in_channels needed # more forward steps Finally, don't forget to warmify the model by adding warm.engine.prepare_model_(self, input_shape_or_data) at the end of the model's __init__() method. You need to supply input_shape_or_data , which is either a tensor of input data, or just its shape, e.g. [1, 1, 28, 28] for MNIST inputs. The model is now ready to use, just like any other PyTorch models. Check out the tutorial and examples if you want to learn more! Testing Clone the repository first, then cd pywarm pytest -v Documentation Examples Tutorial API reference","title":"Home"},{"location":"#pywarm","text":"A cleaner way to build neural networks for PyTorch. | Examples | Tutorial | API reference |","title":"PyWarm"},{"location":"#introduction","text":"PyWarm is a high-level neural network construction API for PyTorch. It only aims to simplify the network definition, and does not cover model training, validation and data handling. With PyWarm, you can put all network data flow logic in the forward() method of your model, without the need to define children modules in the __init__() method. This result in a much more readable model definition in fewer lines of code. For example, a convnet for MNIST: (If needed, click the tabs to switch between Warm and Torch versions) Warm 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # powered by PyWarm import torch.nn as nn import torch.nn.functional as F import warm import warm.functional as W class ConvNet ( nn . Module ): def __init__ ( self ): super () . __init__ () warm . engine . prepare_model_ ( self , [ 1 , 1 , 28 , 28 ]) def forward ( self , x ): x = W . conv ( x , 20 , 5 , activation = 'relu' ) x = F . max_pool2d ( x , 2 ) x = W . conv ( x , 50 , 5 , activation = 'relu' ) x = F . max_pool2d ( x , 2 ) x = x . view ( - 1 , 800 ) x = W . linear ( x , 500 , activation = 'relu' ) x = W . linear ( x , 10 ) return F . log_softmax ( x , dim = 1 ) Torch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # vanilla PyTorch version, taken from # pytorch tutorials/beginner_source/blitz/neural_networks_tutorial.py import torch.nn as nn import torch.nn.functional as F class ConvNet ( nn . Module ): def __init__ ( self ): super () . __init__ () self . conv1 = nn . Conv2d ( 1 , 20 , 5 , 1 ) self . conv2 = nn . Conv2d ( 20 , 50 , 5 , 1 ) self . fc1 = nn . Linear ( 4 * 4 * 50 , 500 ) self . fc2 = nn . Linear ( 500 , 10 ) def forward ( self , x ): x = F . relu ( self . conv1 ( x )) x = F . max_pool2d ( x , 2 , 2 ) x = F . relu ( self . conv2 ( x )) x = F . max_pool2d ( x , 2 , 2 ) x = x . view ( - 1 , 4 * 4 * 50 ) x = F . relu ( self . fc1 ( x )) x = self . fc2 ( x ) return F . log_softmax ( x , dim = 1 ) A couple of things you may have noticed: First of all, in the PyWarm version, the entire network definition and data flow logic resides in the forward() method. You don't have to look up and down repeatedly to understand what self.conv1 , self.fc1 etc. is doing. You do not need to track and specify in_channels (or in_features , etc.) for network layers. PyWarm can infer the information for you. e.g. # Warm x = W . conv ( x , 20 , 5 , activation = 'relu' ) x = W . conv ( x , 50 , 5 , activation = 'relu' ) # Torch self . conv1 = nn . Conv2d ( 1 , 20 , 5 , 1 ) self . conv2 = nn . Conv2d ( 20 , 50 , 5 , 1 ) One unified W.conv for all 1D, 2D, and 3D cases. Fewer things to keep track of! For deeper neural networks, see additional examples .","title":"Introduction"},{"location":"#installation","text":"pip3 install pywarm","title":"Installation"},{"location":"#quick-start-30-seconds-to-pywarm","text":"If you already have experinces with PyTorch, using PyWarm is very straightforward: First, import PyWarm in you model file: import warm import warm.functional as W Second, delete child module definitions in the model's __init__() method. In stead, use W.conv , W.linear ... etc. in the model's forward() method, just like how you would use torch nn functional F.max_pool2d , F.relu ... etc. For example, instead of writing: # Torch class MyModule ( nn . Module ): def __init__ ( self ): super () . __init__ () self . conv1 = nn . Conv2d ( in_channels , out_channels , kernel_size ) # more child module definitions def forward ( self , x ): x = self . conv1 ( x ) # more forward steps You can now write in the warm way: # Warm class MyWarmModule ( nn . Module ): def __init__ ( self ): super () . __init__ () warm . engine . prepare_model_ ( self , input_shape_or_data ) def forward ( self , x ): x = W . conv ( x , out_channels , kernel_size ) # no in_channels needed # more forward steps Finally, don't forget to warmify the model by adding warm.engine.prepare_model_(self, input_shape_or_data) at the end of the model's __init__() method. You need to supply input_shape_or_data , which is either a tensor of input data, or just its shape, e.g. [1, 1, 28, 28] for MNIST inputs. The model is now ready to use, just like any other PyTorch models. Check out the tutorial and examples if you want to learn more!","title":"Quick start: 30 seconds to PyWarm"},{"location":"#testing","text":"Clone the repository first, then cd pywarm pytest -v","title":"Testing"},{"location":"#documentation","text":"Examples Tutorial API reference","title":"Documentation"},{"location":"CONTRIBUTING/","text":"Contributing to PyWarm PyWarm is developed on GitHub . Please use GitHub to file Bug reports and submit pull requests. Please document and test before submissions. PyWarm is developed with Python 3.7, but has been tested to work with Python 3.6+. Coding Style You may have noticed that the source code of PyWarm uses some distinct style conventions. PEP 8 All guidelines here are in addition to or an upgrade of the Python PEP 8 . Max Line Length 120 characters. 79 is too short. Closing Parentheses Put closing parentheses at the same level of the last object. Do not put them on a new line. Yes x = dict ( a = 1 , b = 2 , c = 3 , d = 4 , ) # closing parentheses same line, yes No x = dict ( a = 1 , b = 2 , c = 3 , d = 4 ) # closing parentheses separate line, no Indentation Indent 1 level (4 spaces) for line continuation, or 2 levels to distinguish from the next line. Never align with opening delimiter: Yes foo = long_function_name ( var_one = 1 , var_two = 2 , var_three = 3 , var_four = 4 , ) # 1 level indent, yes No # what if the function name plus indent is really long, like 70 characters? foo = long_function_name ( var_one = 1 , var_two = 2 , var_three = 3 , var_four = 4 ) # align, no Blank Lines Completely avoid blank lines inside function and methods. Instead, organize / refactor the code to be cleaner and shorter. If there is a really strong need, use an empty comment at the same level of indentation. Type Annotations Don't use. Instead, write detailed type information in the docstring. Inline comments Keep them to a minimum. Comments should reflect intentions, not echo implementaions. String Quotes In code, use single-quote '' whenever possible. For docstring, use triple double quotes: \"\"\" \"\"\" . Naming Conventions If you don't want others to mess around with an object, add a single underscore before its name: _do_not_mess_with_me If a function / method alters its inputs, add a single underscore after it: i_mess_with_inputs_ ( x ) # content of x will change after each call","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-to-pywarm","text":"PyWarm is developed on GitHub . Please use GitHub to file Bug reports and submit pull requests. Please document and test before submissions. PyWarm is developed with Python 3.7, but has been tested to work with Python 3.6+.","title":"Contributing to PyWarm"},{"location":"CONTRIBUTING/#coding-style","text":"You may have noticed that the source code of PyWarm uses some distinct style conventions.","title":"Coding Style"},{"location":"CONTRIBUTING/#pep-8","text":"All guidelines here are in addition to or an upgrade of the Python PEP 8 .","title":"PEP 8"},{"location":"CONTRIBUTING/#max-line-length","text":"120 characters. 79 is too short.","title":"Max Line Length"},{"location":"CONTRIBUTING/#closing-parentheses","text":"Put closing parentheses at the same level of the last object. Do not put them on a new line. Yes x = dict ( a = 1 , b = 2 , c = 3 , d = 4 , ) # closing parentheses same line, yes No x = dict ( a = 1 , b = 2 , c = 3 , d = 4 ) # closing parentheses separate line, no","title":"Closing Parentheses"},{"location":"CONTRIBUTING/#indentation","text":"Indent 1 level (4 spaces) for line continuation, or 2 levels to distinguish from the next line. Never align with opening delimiter: Yes foo = long_function_name ( var_one = 1 , var_two = 2 , var_three = 3 , var_four = 4 , ) # 1 level indent, yes No # what if the function name plus indent is really long, like 70 characters? foo = long_function_name ( var_one = 1 , var_two = 2 , var_three = 3 , var_four = 4 ) # align, no","title":"Indentation"},{"location":"CONTRIBUTING/#blank-lines","text":"Completely avoid blank lines inside function and methods. Instead, organize / refactor the code to be cleaner and shorter. If there is a really strong need, use an empty comment at the same level of indentation.","title":"Blank Lines"},{"location":"CONTRIBUTING/#type-annotations","text":"Don't use. Instead, write detailed type information in the docstring.","title":"Type Annotations"},{"location":"CONTRIBUTING/#inline-comments","text":"Keep them to a minimum. Comments should reflect intentions, not echo implementaions.","title":"Inline comments"},{"location":"CONTRIBUTING/#string-quotes","text":"In code, use single-quote '' whenever possible. For docstring, use triple double quotes: \"\"\" \"\"\" .","title":"String Quotes"},{"location":"CONTRIBUTING/#naming-conventions","text":"If you don't want others to mess around with an object, add a single underscore before its name: _do_not_mess_with_me If a function / method alters its inputs, add a single underscore after it: i_mess_with_inputs_ ( x ) # content of x will change after each call","title":"Naming Conventions"},{"location":"docs/example/","text":"PyWarm Examples ResNet A more detailed example, the ResNet18 network defined in PyWarm and vanilla PyTorch: Warm 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import torch import torch.nn as nn import torch.nn.functional as F import warm import warm.functional as W def basic ( x , size , stride ): y = W . conv ( x , size , 3 , stride = stride , padding = 1 , bias = False ) y = W . batch_norm ( y , activation = 'relu' ) y = W . conv ( y , size , 3 , stride = 1 , padding = 1 , bias = False ) y = W . batch_norm ( y ) if y . shape [ 1 ] != x . shape [ 1 ]: # channel size mismatch, needs projection x = W . conv ( x , y . shape [ 1 ], 1 , stride = stride , bias = False ) x = W . batch_norm ( x ) y = y + x # residual shortcut connection return F . relu ( y ) def stack ( x , num_block , size , stride , block = basic ): for s in [ stride ] + [ 1 ] * ( num_block - 1 ): x = block ( x , size , s ) return x class ResNet ( nn . Module ): def __init__ ( self , block = basic , stack_spec = (( 2 , 64 , 1 ), ( 2 , 128 , 2 ), ( 2 , 256 , 2 ), ( 2 , 512 , 2 ))): super () . __init__ () self . block = block self . stack_spec = stack_spec warm . engine . prepare_model_ ( self , [ 2 , 3 , 32 , 32 ]) def forward ( self , x ): y = W . conv ( x , 64 , 7 , stride = 2 , padding = 3 , bias = False ) y = W . batch_norm ( y , activation = 'relu' ) y = F . max_pool2d ( y , 3 , stride = 2 , padding = 1 ) for spec in self . stack_spec : y = stack ( y , * spec , block = self . block ) y = F . adaptive_avg_pool2d ( y , 1 ) y = torch . flatten ( y , 1 ) y = W . linear ( y , 1000 ) return y resnet18 = ResNet () Torch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 # code based on torchvision/models/resnet.py import torch import torch.nn as nn import torch.nn.functional as F class BasicBlock ( nn . Module ): expansion = 1 def __init__ ( self , in_channels , out_channels , stride = 1 ): super () . __init__ () self . residual_function = nn . Sequential ( nn . Conv2d ( in_channels , out_channels , kernel_size = 3 , stride = stride , padding = 1 , bias = False ), nn . BatchNorm2d ( out_channels ), nn . ReLU ( inplace = True ), nn . Conv2d ( out_channels , out_channels * BasicBlock . expansion , kernel_size = 3 , padding = 1 , bias = False ), nn . BatchNorm2d ( out_channels * BasicBlock . expansion ), ) self . shortcut = nn . Sequential () if stride != 1 or in_channels != BasicBlock . expansion * out_channels : self . shortcut = nn . Sequential ( nn . Conv2d ( in_channels , out_channels * BasicBlock . expansion , kernel_size = 1 , stride = stride , bias = False ), nn . BatchNorm2d ( out_channels * BasicBlock . expansion ), ) def forward ( self , x ): y = self . residual_function ( x ) + self . shortcut ( x ) return F . relu ( y ) class ResNet ( nn . Module ): def __init__ ( self , block = BasicBlock , num_block = [ 2 , 2 , 2 , 2 ]): super () . __init__ () self . in_channels = 64 self . conv1 = nn . Sequential ( nn . Conv2d ( 3 , 64 , kernel_size = 7 , stride = 2 , padding = 3 , bias = False ), nn . BatchNorm2d ( 64 ), nn . ReLU ( inplace = True ), ) self . conv2 = self . _make_stack ( block , 64 , num_block [ 0 ], 1 ) self . conv3 = self . _make_stack ( block , 128 , num_block [ 1 ], 2 ) self . conv4 = self . _make_stack ( block , 256 , num_block [ 2 ], 2 ) self . conv5 = self . _make_stack ( block , 512 , num_block [ 3 ], 2 ) self . avg_pool = nn . AdaptiveAvgPool2d (( 1 , 1 )) self . fc = nn . Linear ( 512 * block . expansion , 1000 ) def _make_stack ( self , block , out_channels , num_blocks , stride ): strides = [ stride ] + [ 1 ] * ( num_blocks - 1 ) stacks = [] for stride in strides : stacks . append ( block ( self . in_channels , out_channels , stride )) self . in_channels = out_channels * block . expansion return nn . Sequential ( * stacks ) def forward ( self , x ): y = self . conv1 ( x ) y = self . conv2 ( y ) y = self . conv3 ( y ) y = self . conv4 ( y ) y = self . conv5 ( y ) y = self . avg_pool ( y ) y = y . view ( y . size ( 0 ), - 1 ) y = self . fc ( y ) return y resnet18 = ResNet () The vanilla PyTorch version uses a expansion constant in the model class to track input - output size changes. It is not needed in the PyWarm version. As a result, the logic to determine additional projection is much more straightforward in PyWarm: # Warm if y . shape [ 1 ] != x . shape [ 1 ]: # 1x1 conv to project channel size of x to y. # Torch if stride != 1 or in_channels != BasicBlock . expansion * out_channels : # 1x1 conv to project channel size of x to y.","title":"Example"},{"location":"docs/example/#pywarm-examples","text":"","title":"PyWarm Examples"},{"location":"docs/example/#resnet","text":"A more detailed example, the ResNet18 network defined in PyWarm and vanilla PyTorch: Warm 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import torch import torch.nn as nn import torch.nn.functional as F import warm import warm.functional as W def basic ( x , size , stride ): y = W . conv ( x , size , 3 , stride = stride , padding = 1 , bias = False ) y = W . batch_norm ( y , activation = 'relu' ) y = W . conv ( y , size , 3 , stride = 1 , padding = 1 , bias = False ) y = W . batch_norm ( y ) if y . shape [ 1 ] != x . shape [ 1 ]: # channel size mismatch, needs projection x = W . conv ( x , y . shape [ 1 ], 1 , stride = stride , bias = False ) x = W . batch_norm ( x ) y = y + x # residual shortcut connection return F . relu ( y ) def stack ( x , num_block , size , stride , block = basic ): for s in [ stride ] + [ 1 ] * ( num_block - 1 ): x = block ( x , size , s ) return x class ResNet ( nn . Module ): def __init__ ( self , block = basic , stack_spec = (( 2 , 64 , 1 ), ( 2 , 128 , 2 ), ( 2 , 256 , 2 ), ( 2 , 512 , 2 ))): super () . __init__ () self . block = block self . stack_spec = stack_spec warm . engine . prepare_model_ ( self , [ 2 , 3 , 32 , 32 ]) def forward ( self , x ): y = W . conv ( x , 64 , 7 , stride = 2 , padding = 3 , bias = False ) y = W . batch_norm ( y , activation = 'relu' ) y = F . max_pool2d ( y , 3 , stride = 2 , padding = 1 ) for spec in self . stack_spec : y = stack ( y , * spec , block = self . block ) y = F . adaptive_avg_pool2d ( y , 1 ) y = torch . flatten ( y , 1 ) y = W . linear ( y , 1000 ) return y resnet18 = ResNet () Torch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 # code based on torchvision/models/resnet.py import torch import torch.nn as nn import torch.nn.functional as F class BasicBlock ( nn . Module ): expansion = 1 def __init__ ( self , in_channels , out_channels , stride = 1 ): super () . __init__ () self . residual_function = nn . Sequential ( nn . Conv2d ( in_channels , out_channels , kernel_size = 3 , stride = stride , padding = 1 , bias = False ), nn . BatchNorm2d ( out_channels ), nn . ReLU ( inplace = True ), nn . Conv2d ( out_channels , out_channels * BasicBlock . expansion , kernel_size = 3 , padding = 1 , bias = False ), nn . BatchNorm2d ( out_channels * BasicBlock . expansion ), ) self . shortcut = nn . Sequential () if stride != 1 or in_channels != BasicBlock . expansion * out_channels : self . shortcut = nn . Sequential ( nn . Conv2d ( in_channels , out_channels * BasicBlock . expansion , kernel_size = 1 , stride = stride , bias = False ), nn . BatchNorm2d ( out_channels * BasicBlock . expansion ), ) def forward ( self , x ): y = self . residual_function ( x ) + self . shortcut ( x ) return F . relu ( y ) class ResNet ( nn . Module ): def __init__ ( self , block = BasicBlock , num_block = [ 2 , 2 , 2 , 2 ]): super () . __init__ () self . in_channels = 64 self . conv1 = nn . Sequential ( nn . Conv2d ( 3 , 64 , kernel_size = 7 , stride = 2 , padding = 3 , bias = False ), nn . BatchNorm2d ( 64 ), nn . ReLU ( inplace = True ), ) self . conv2 = self . _make_stack ( block , 64 , num_block [ 0 ], 1 ) self . conv3 = self . _make_stack ( block , 128 , num_block [ 1 ], 2 ) self . conv4 = self . _make_stack ( block , 256 , num_block [ 2 ], 2 ) self . conv5 = self . _make_stack ( block , 512 , num_block [ 3 ], 2 ) self . avg_pool = nn . AdaptiveAvgPool2d (( 1 , 1 )) self . fc = nn . Linear ( 512 * block . expansion , 1000 ) def _make_stack ( self , block , out_channels , num_blocks , stride ): strides = [ stride ] + [ 1 ] * ( num_blocks - 1 ) stacks = [] for stride in strides : stacks . append ( block ( self . in_channels , out_channels , stride )) self . in_channels = out_channels * block . expansion return nn . Sequential ( * stacks ) def forward ( self , x ): y = self . conv1 ( x ) y = self . conv2 ( y ) y = self . conv3 ( y ) y = self . conv4 ( y ) y = self . conv5 ( y ) y = self . avg_pool ( y ) y = y . view ( y . size ( 0 ), - 1 ) y = self . fc ( y ) return y resnet18 = ResNet () The vanilla PyTorch version uses a expansion constant in the model class to track input - output size changes. It is not needed in the PyWarm version. As a result, the logic to determine additional projection is much more straightforward in PyWarm: # Warm if y . shape [ 1 ] != x . shape [ 1 ]: # 1x1 conv to project channel size of x to y. # Torch if stride != 1 or in_channels != BasicBlock . expansion * out_channels : # 1x1 conv to project channel size of x to y.","title":"ResNet"},{"location":"docs/tutorial/","text":"PyWarm Tutorial Import To get started, first import PyWarm in your project: import warm import warm.functional as W Rewrite Now you can replace child module definitions with function calls. For example, instead of: # Torch class MyModule ( nn . Module ): def __init__ ( self ): super () . __init__ () self . conv1 = nn . Conv2d ( in_channels , out_channels , kernel_size ) # more child module definitions def forward ( self , x ): x = self . conv1 ( x ) # more forward steps You now use the warm functions: # Warm class MyWarmModule ( nn . Module ): def __init__ ( self ): super () . __init__ () warm . engine . prepare_model_ ( self , input_shape_or_data ) def forward ( self , x ): x = W . conv ( x , out_channels , kernel_size ) # no in_channels needed # more forward steps Notice the warm.engine.prepare_model_(self, input_shape_or_data) at the end of the __init__() method. It is required so that PyWarm can infer all shapes of itermediate steps and set up trainable parameters. The only argument input_shape_or_data can either be a tensor, e.g. torch.randn(1, 1, 28, 28) , or just the shape, e.g. [1, 1, 28, 28] for the model inputs. If the model has multiple inputs, you may supple them in a list or a dictionary. Default shapes PyWarm has a unified functional interface, that by default all functions accept and return tensors with shape (Batch, Channel, *) , where * is any number of additional dimensions. For example, for 2d images, the * usually stands for (Height, Width) , and for 1d time series, the * means (Time,) . This convention is optimized for the performance of Convolutional networks. It may be less optimal if your model relies heavily on dense (Linear) or recurrent (LSTM, GRU) layers. You can specify differnt input and output shapes by specifying in_shape , out_shape keyword arguments in the function calls. These keywords accept only letters 'B' , 'C' and 'D' , which stand for Batch , Channel , and * (extra Dimensions) respectively. So for example if for a 1d time series you want to have (Time, Batch, Channel) as the output shape, you can specify out_shape='DBC' . Dimensional awareness PyWarm functions can automatically identify 1d, 2d and 3d input data, so the same function can be used on different dimensional cases. For example, the single W.conv is enough to replace nn.Conv1d, nn.Conv2d, nn.Conv3d . Similarly, you don't need nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d for differnt inputs, a single W.batch_norm can replace them all. Shape inference Many neural network layers result in a transformation of shapes, for example a convolution operation changes shape from (Batch, ChannelIn, *) to (Batch, ChannelOut, *) . PyTorch nn Modules require the users to keep track of both in_channels and out_channels . PyWarm relives this pain by inferring the in_channels for you, so you can focus more on the nature of the operation, rather than chores. Argument passdown If a PyWarm function's signature does not specify all possible argument of its nn Module couterpart, it will pass down additional keyword arguments to the underlying nn Module. For example, if you want to specify strides to 2 for a conv layer, just use W.conv(..., stride=2) . The only thing to remember is that you have to specify the full keyword, rather than relying on the position of arguments. Optional activation keyword PyWarm's functional interface support adding an optional keyword argument activation=name , where name is a callable or just its name, which represents an activation (nonlinearity) functions in torch.nn.init . By default no activation is used. Mix Match You are not limited to just use PyWarm's functional interface. It is completely ok to mix and match the old PyTorch way of child module definitions with PyWarm's functions. For example: class MyModel ( nn . Module ): def __init__ ( self ): super () . __init__ () # more stuff self . conv1 = nn . Conv2d ( 2 , 30 , 7 , padding = 3 ) # more stuff def forward ( self , x ): y = F . relu ( self . conv1 ( x )) y = W . conv ( y , 40 , 3 , activation = 'relu' )","title":"Tutorial"},{"location":"docs/tutorial/#pywarm-tutorial","text":"","title":"PyWarm Tutorial"},{"location":"docs/tutorial/#import","text":"To get started, first import PyWarm in your project: import warm import warm.functional as W","title":"Import"},{"location":"docs/tutorial/#rewrite","text":"Now you can replace child module definitions with function calls. For example, instead of: # Torch class MyModule ( nn . Module ): def __init__ ( self ): super () . __init__ () self . conv1 = nn . Conv2d ( in_channels , out_channels , kernel_size ) # more child module definitions def forward ( self , x ): x = self . conv1 ( x ) # more forward steps You now use the warm functions: # Warm class MyWarmModule ( nn . Module ): def __init__ ( self ): super () . __init__ () warm . engine . prepare_model_ ( self , input_shape_or_data ) def forward ( self , x ): x = W . conv ( x , out_channels , kernel_size ) # no in_channels needed # more forward steps Notice the warm.engine.prepare_model_(self, input_shape_or_data) at the end of the __init__() method. It is required so that PyWarm can infer all shapes of itermediate steps and set up trainable parameters. The only argument input_shape_or_data can either be a tensor, e.g. torch.randn(1, 1, 28, 28) , or just the shape, e.g. [1, 1, 28, 28] for the model inputs. If the model has multiple inputs, you may supple them in a list or a dictionary.","title":"Rewrite"},{"location":"docs/tutorial/#default-shapes","text":"PyWarm has a unified functional interface, that by default all functions accept and return tensors with shape (Batch, Channel, *) , where * is any number of additional dimensions. For example, for 2d images, the * usually stands for (Height, Width) , and for 1d time series, the * means (Time,) . This convention is optimized for the performance of Convolutional networks. It may be less optimal if your model relies heavily on dense (Linear) or recurrent (LSTM, GRU) layers. You can specify differnt input and output shapes by specifying in_shape , out_shape keyword arguments in the function calls. These keywords accept only letters 'B' , 'C' and 'D' , which stand for Batch , Channel , and * (extra Dimensions) respectively. So for example if for a 1d time series you want to have (Time, Batch, Channel) as the output shape, you can specify out_shape='DBC' .","title":"Default shapes"},{"location":"docs/tutorial/#dimensional-awareness","text":"PyWarm functions can automatically identify 1d, 2d and 3d input data, so the same function can be used on different dimensional cases. For example, the single W.conv is enough to replace nn.Conv1d, nn.Conv2d, nn.Conv3d . Similarly, you don't need nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d for differnt inputs, a single W.batch_norm can replace them all.","title":"Dimensional awareness"},{"location":"docs/tutorial/#shape-inference","text":"Many neural network layers result in a transformation of shapes, for example a convolution operation changes shape from (Batch, ChannelIn, *) to (Batch, ChannelOut, *) . PyTorch nn Modules require the users to keep track of both in_channels and out_channels . PyWarm relives this pain by inferring the in_channels for you, so you can focus more on the nature of the operation, rather than chores.","title":"Shape inference"},{"location":"docs/tutorial/#argument-passdown","text":"If a PyWarm function's signature does not specify all possible argument of its nn Module couterpart, it will pass down additional keyword arguments to the underlying nn Module. For example, if you want to specify strides to 2 for a conv layer, just use W.conv(..., stride=2) . The only thing to remember is that you have to specify the full keyword, rather than relying on the position of arguments.","title":"Argument passdown"},{"location":"docs/tutorial/#optional-activation-keyword","text":"PyWarm's functional interface support adding an optional keyword argument activation=name , where name is a callable or just its name, which represents an activation (nonlinearity) functions in torch.nn.init . By default no activation is used.","title":"Optional activation keyword"},{"location":"docs/tutorial/#mix-match","text":"You are not limited to just use PyWarm's functional interface. It is completely ok to mix and match the old PyTorch way of child module definitions with PyWarm's functions. For example: class MyModel ( nn . Module ): def __init__ ( self ): super () . __init__ () # more stuff self . conv1 = nn . Conv2d ( 2 , 30 , 7 , padding = 3 ) # more stuff def forward ( self , x ): y = F . relu ( self . conv1 ( x )) y = W . conv ( y , 40 , 3 , activation = 'relu' )","title":"Mix Match"},{"location":"reference/warm/","text":"Module warm Sub-modules warm.engine warm.functional warm.module warm.util","title":"Index"},{"location":"reference/warm/#module-warm","text":"","title":"Module warm"},{"location":"reference/warm/#sub-modules","text":"warm.engine warm.functional warm.module warm.util","title":"Sub-modules"},{"location":"reference/warm/engine/","text":"Module warm.engine PyWarm engine to the functional interface. Functions activate def : x , spec , lookup = None Activate tensors with given nonlinearity spec ification. x: Tensor or list of Tensor ; The tensors to be initialized. spec: str or callable or 2-tuple ; If a str , should be one of the nonlinearity functions contained in torch.nn.functional or torch . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . lookup: None or list of module ; Parent modules to look for spec . If None , [nn.functional, torch] is used. return: Tensor or list of Tensor ; Activation results. forward def : x , base_class , base_name = None , name = None , base_arg = None , base_kw = None , parent = None , infer_kw = None , in_shape = 'BCD' , base_shape = 'BCD' , out_shape = 'BCD' , tuple_out = False , forward_arg = None , forward_kw = None , initialization = None , activation = None , ** kw A forward template that creates child instances at the first time it is called. x: Tensor ; The nd-tensor to be forwarded. base_class: Module ; A child torch.nn.Module that will be created at the first time this function is called. base_name: str ; Name for the base_class . Default: base_class name. name: str ; Name for the child module instance. Default: class name plus ordinal. base_arg: tuple ; Positional args to be passed to create the child module instance. Default: None. base_kw: dict ; KWargs to be passed to create the child module instance. Default: None. parent: Module ; The parent of the child instance. Default: None. If None , will use get_default_parent . infer_kw: dict ; Key should be valid for the child instance. Value shoud be a character, one of 'B' , 'C' , or 'D' (see permute ), to substitute for a dimension of x . Default: None. in_shape: str ; The dimension shape of x . See also permute . Default: 'BCD' . base_shape: str ; The dimension shape required by the child module. See also permute . Default: 'BCD' . out_shape: str or tuple or None ; The dimension shape of returned tensor. See also permute . Default: 'BCD' . tuple_out: bool ; Whether the child module will return more than 1 outputs (e.g. nn.RNN ). If True , the returned value of the function will be a tuple containing all outputs. Default: False. forward_arg: tuple ; positional args to be passed when calling the child module instance. Default: None. forward_kw: dict ; KWargs to be passed when calling the child module instance. Default: None. initialization: str or callable or 2-tuple ; See the spec argument of initialize_ . Default: None. activation: str or callable or 2-tuple ; See the spec argument of activate . Default: None. return: Tensor or tuple ; If tuple_out is True , the returned value will be a tuple . get_default_parent def : Get the default parent module. initialize_ def : x , spec Initialize parameters with given nonlinearity spec ification. x: Tensor or list of Tensor ; The tensors to be initialized. spec: str or callable or 2-tuple ; If a str , should be one of the nonlinearity functions contained in torch.nn.init . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . is_ready def : model Check if a model is prepared. permute def : x , in_shape = 'BCD' , out_shape = 'BCD' , ** kw Permute the dimensions of a tensor. x: Tensor ; The nd-tensor to be permuted. in_shape: str ; The dimension shape of x . Can only have characters 'B' or 'C' or 'D' , which stand for Batch, Channel, or extra Dimensions. The default value 'BCD' means the input tensor x should be at lest 2-d with shape (Batch, Channel, Dim0, Dim1, Dim2, ...) , where Dim0, Dim1, Dim2 ... stand for any number of extra dimensions. out_shape: str or tuple or None ; The dimension shape of returned tensor. Default: 'BCD' . If a str , it is restricted to the same three characters 'B' , 'C' or 'D' as the in_shape . If a tuple , in_shape is ignored, and simply x.permute(out_shape) is returned. If None , no permution will be performed. return: Tensor ; Permuted nd-tensor. prepare_model_ def : model , data , device = 'cpu' Initialize all childen modules defined by warm in a parent model . model: Module ; The parent model to be prepared. data: Tensor, or list of int ; A batch of data with the correct shape and type to be forwarded by model. data can also be a list of int , in which case it is interpreted as the shape of the input data. device: str, or torch.device ; Should be the same for model and data . Default: 'cpu' . return: Module ; The prepared model, with all children modules defined by warm initialized. set_default_parent def : parent Set the default parent module. unused_kwargs def : kw Filter out entries used by forward and return the rest.","title":"Engine"},{"location":"reference/warm/engine/#module-warmengine","text":"PyWarm engine to the functional interface.","title":"Module warm.engine"},{"location":"reference/warm/engine/#functions","text":"","title":"Functions"},{"location":"reference/warm/engine/#activate","text":"def : x , spec , lookup = None Activate tensors with given nonlinearity spec ification. x: Tensor or list of Tensor ; The tensors to be initialized. spec: str or callable or 2-tuple ; If a str , should be one of the nonlinearity functions contained in torch.nn.functional or torch . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . lookup: None or list of module ; Parent modules to look for spec . If None , [nn.functional, torch] is used. return: Tensor or list of Tensor ; Activation results.","title":"activate"},{"location":"reference/warm/engine/#forward","text":"def : x , base_class , base_name = None , name = None , base_arg = None , base_kw = None , parent = None , infer_kw = None , in_shape = 'BCD' , base_shape = 'BCD' , out_shape = 'BCD' , tuple_out = False , forward_arg = None , forward_kw = None , initialization = None , activation = None , ** kw A forward template that creates child instances at the first time it is called. x: Tensor ; The nd-tensor to be forwarded. base_class: Module ; A child torch.nn.Module that will be created at the first time this function is called. base_name: str ; Name for the base_class . Default: base_class name. name: str ; Name for the child module instance. Default: class name plus ordinal. base_arg: tuple ; Positional args to be passed to create the child module instance. Default: None. base_kw: dict ; KWargs to be passed to create the child module instance. Default: None. parent: Module ; The parent of the child instance. Default: None. If None , will use get_default_parent . infer_kw: dict ; Key should be valid for the child instance. Value shoud be a character, one of 'B' , 'C' , or 'D' (see permute ), to substitute for a dimension of x . Default: None. in_shape: str ; The dimension shape of x . See also permute . Default: 'BCD' . base_shape: str ; The dimension shape required by the child module. See also permute . Default: 'BCD' . out_shape: str or tuple or None ; The dimension shape of returned tensor. See also permute . Default: 'BCD' . tuple_out: bool ; Whether the child module will return more than 1 outputs (e.g. nn.RNN ). If True , the returned value of the function will be a tuple containing all outputs. Default: False. forward_arg: tuple ; positional args to be passed when calling the child module instance. Default: None. forward_kw: dict ; KWargs to be passed when calling the child module instance. Default: None. initialization: str or callable or 2-tuple ; See the spec argument of initialize_ . Default: None. activation: str or callable or 2-tuple ; See the spec argument of activate . Default: None. return: Tensor or tuple ; If tuple_out is True , the returned value will be a tuple .","title":"forward"},{"location":"reference/warm/engine/#get_default_parent","text":"def : Get the default parent module.","title":"get_default_parent"},{"location":"reference/warm/engine/#initialize_","text":"def : x , spec Initialize parameters with given nonlinearity spec ification. x: Tensor or list of Tensor ; The tensors to be initialized. spec: str or callable or 2-tuple ; If a str , should be one of the nonlinearity functions contained in torch.nn.init . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) .","title":"initialize_"},{"location":"reference/warm/engine/#is_ready","text":"def : model Check if a model is prepared.","title":"is_ready"},{"location":"reference/warm/engine/#permute","text":"def : x , in_shape = 'BCD' , out_shape = 'BCD' , ** kw Permute the dimensions of a tensor. x: Tensor ; The nd-tensor to be permuted. in_shape: str ; The dimension shape of x . Can only have characters 'B' or 'C' or 'D' , which stand for Batch, Channel, or extra Dimensions. The default value 'BCD' means the input tensor x should be at lest 2-d with shape (Batch, Channel, Dim0, Dim1, Dim2, ...) , where Dim0, Dim1, Dim2 ... stand for any number of extra dimensions. out_shape: str or tuple or None ; The dimension shape of returned tensor. Default: 'BCD' . If a str , it is restricted to the same three characters 'B' , 'C' or 'D' as the in_shape . If a tuple , in_shape is ignored, and simply x.permute(out_shape) is returned. If None , no permution will be performed. return: Tensor ; Permuted nd-tensor.","title":"permute"},{"location":"reference/warm/engine/#prepare_model_","text":"def : model , data , device = 'cpu' Initialize all childen modules defined by warm in a parent model . model: Module ; The parent model to be prepared. data: Tensor, or list of int ; A batch of data with the correct shape and type to be forwarded by model. data can also be a list of int , in which case it is interpreted as the shape of the input data. device: str, or torch.device ; Should be the same for model and data . Default: 'cpu' . return: Module ; The prepared model, with all children modules defined by warm initialized.","title":"prepare_model_"},{"location":"reference/warm/engine/#set_default_parent","text":"def : parent Set the default parent module.","title":"set_default_parent"},{"location":"reference/warm/engine/#unused_kwargs","text":"def : kw Filter out entries used by forward and return the rest.","title":"unused_kwargs"},{"location":"reference/warm/functional/","text":"Module warm.functional Wraps around various torch.nn Modules to fit into a functional interface. Functions batch_norm def : x , ** kw Batch Normalization layer. x: Tensor ; 2d or more, with shapes (Batch, Channel, *) where * means any number of additional dimensions. **kw: dict ; Any additional KWargs are passed down to torch.nn.BatchNormNd , where N can be 1, 2 or 3. as well as warm.engine.forward . Refer to their docs for details. Some of the additional BatchNorm arguments: eps, momentum, affine, track_running_stats . return: Tensor ; Same shape as input x . conv def : x , size , kernel , init_weight = None , init_bias = None , bias = True , ** kw Convolution layer. x: Tensor ; With shape (Batch, Channel, *) where * Can be 1d or 2d or 3d. If 3d, shapes are (Batch, Channel, Length) . If 4d, shapes are (Batch, Channel, Height, Width) . If 5d, shapes are (Batch, Channel, Depth, Height, Width) . size: int ; Size of hidden filters, and size of the output channel. kernel: int or tuple ; Size of the convolution kernel. init_weight: None or str or callable ; Initialization specification for the weight tensor. If a str , should be one of the nonlinearity functions contained in torch.nn.init . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . Default: None , and the weight tensor is initialized using torch.nn.ConvNd s default scheme. init_bias: None or str or callable ; Same as init_weight , but for the bias tensor. bias: bool ; If True , adds a learnable bias to the output. Default: True . **kw:dict ; Any additional KWargs are passed down to torch.nn.ConvNd , where N can be 1, 2 or 3. as well as warm.engine.forward . Refer to their docs for details. Some of the additional ConvNd arguments: stride, padding, dilation, groups . return: Tensor ; With shape (Batch, Size, *) where * can be 1d, 2d, 3d that depends on x . dropout def : x , rate = 0.5 , by_channel = False , ** kw Dropout layer. During training, randomly zeros part of input tensor x , at probability rate . x: Tensor ; Can be of any shape if by_channel is false, or 2d and up if by_channel is true. rate: float ; The probability of dropout. Default 0.5. by_channel: bool ; If true, will dropout entire channels (all 'D' dimensions will be 0 if x is 'BCD' ). by_channel true requires x to be 2d or more. inplace: bool ; If true, the operation will be in-place and the input x will be altered. return: Tensor ; Same shape as x . gru def : * arg , ** kw Gated Recurrent Unit layer. x: Tensor ; 3d, with shapes (Batch, Channel, Length) . size: int ; Size of hidden features, and size of the output channel. init_weight_hh: None or str or callable ; Initialization specification for the hidden-hidden weight tensor. If a str , should be one of the nonlinearity functions contained in torch.nn.init . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . Default: 'orthogonal_' . init_weight_ih: None or str or callable ; Initialization specification for the input-hidden weight tensor. Default: None , and the weight tensor is initialized using torch.nn.GRU s default scheme. init_bias_hh: None or str or callable ; Initialization specification for the hidden-hidden bias tensor. Default: None , and the weight tensor is initialized using torch.nn.GRU s default scheme. init_bias_ih: None or str or callable ; Initialization specification for the input-hidden bias tensor. Default: None , and the weight tensor is initialized using torch.nn.GRU s default scheme. bias: bool ; If False , then the layer does not use bias_ih and bias_hh . Default: True . num_layers: int ; Number of the recurrent layers. Default: 1. tuple_out: bool ; If True , the returned value will be a tuple (out, (h_n, c_n)) . Default: False. **kw: dict ; Any additional KWargs are passed down to torch.nn.GRU , as well as warm.engine.forward . Refer to their docs for details. Some of the additional GRU arguments: dropout, bidirectional, batch_first . return: Tensor or tuple ; If tuple_out set to true, will return (out, (h_n, c_n) , otherwise just out . out has shape (Batch, Size, Length*Directions) , where Directions = 2 if bidirectional else 1. h_n is the hidden states with shape (num_layers*Directions, Batch, Size) . c_n is the cell states with shape (num_layers*Directions, Batch, Size) . identity def : x , * arg , ** kw Identity layer that returns the first input, ignores the rest arguments. linear def : x , size , init_weight = None , init_bias = None , bias = True , ** kw Linear transformation layer. x: Tensor ; 2d or more, with shapes (Batch, Channel, *) where * means any number of additional dimensions. size: int ; Size of hidden features, and size of the output channel. init_weight: None or str or callable ; Initialization specification for the weight tensor. If a str , should be one of the nonlinearity functions contained in torch.nn.init . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . Default: None , and the weight tensor is initialized using torch.nn.Linear s default scheme. init_bias: None or str or callable ; Same as init_weight , but for the bias tensor. bias: bool ; If True , adds a learnable bias to the output. Default: True . **kw:dict ; Any additional KWargs are passed down to warm.engine.forward . Refer to its docs for details. return: Tensor ; With shape (Batch, Size, *) where * can be 1d, 2d, 3d that depends on x . lstm def : x , size , init_weight_hh = 'orthogonal_' , init_weight_ih = None , init_bias_hh = None , init_bias_ih = None , bias = True , num_layers = 1 , ** kw Long Short Term Memory layer. x: Tensor ; 3d, with shapes (Batch, Channel, Length) . size: int ; Size of hidden features, and size of the output channel. init_weight_hh: None or str or callable ; Initialization specification for the hidden-hidden weight tensor. If a str , should be one of the nonlinearity functions contained in torch.nn.init . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . Default: 'orthogonal_' . init_weight_ih: None or str or callable ; Initialization specification for the input-hidden weight tensor. Default: None , and the weight tensor is initialized using torch.nn.LSTM s default scheme. init_bias_hh: None or str or callable ; Initialization specification for the hidden-hidden bias tensor. Default: None , and the weight tensor is initialized using torch.nn.LSTM s default scheme. init_bias_ih: None or str or callable ; Initialization specification for the input-hidden bias tensor. Default: None , and the weight tensor is initialized using torch.nn.LSTM s default scheme. bias: bool ; If False , then the layer does not use bias_ih and bias_hh . Default: True . num_layers: int ; Number of the recurrent layers. Default: 1. tuple_out: bool ; If True , the returned value will be a tuple (out, (h_n, c_n)) . Default: False. **kw: dict ; Any additional KWargs are passed down to torch.nn.LSTM , as well as warm.engine.forward . Refer to their docs for details. Some of the additional LSTM arguments: dropout, bidirectional, batch_first . return: Tensor or tuple ; If tuple_out set to true, will return (out, (h_n, c_n) , otherwise just out . out has shape (Batch, Size, Length*Directions) , where Directions = 2 if bidirectional else 1. h_n is the hidden states with shape (num_layers*Directions, Batch, Size) . c_n is the cell states with shape (num_layers*Directions, Batch, Size) .","title":"Functional"},{"location":"reference/warm/functional/#module-warmfunctional","text":"Wraps around various torch.nn Modules to fit into a functional interface.","title":"Module warm.functional"},{"location":"reference/warm/functional/#functions","text":"","title":"Functions"},{"location":"reference/warm/functional/#batch_norm","text":"def : x , ** kw Batch Normalization layer. x: Tensor ; 2d or more, with shapes (Batch, Channel, *) where * means any number of additional dimensions. **kw: dict ; Any additional KWargs are passed down to torch.nn.BatchNormNd , where N can be 1, 2 or 3. as well as warm.engine.forward . Refer to their docs for details. Some of the additional BatchNorm arguments: eps, momentum, affine, track_running_stats . return: Tensor ; Same shape as input x .","title":"batch_norm"},{"location":"reference/warm/functional/#conv","text":"def : x , size , kernel , init_weight = None , init_bias = None , bias = True , ** kw Convolution layer. x: Tensor ; With shape (Batch, Channel, *) where * Can be 1d or 2d or 3d. If 3d, shapes are (Batch, Channel, Length) . If 4d, shapes are (Batch, Channel, Height, Width) . If 5d, shapes are (Batch, Channel, Depth, Height, Width) . size: int ; Size of hidden filters, and size of the output channel. kernel: int or tuple ; Size of the convolution kernel. init_weight: None or str or callable ; Initialization specification for the weight tensor. If a str , should be one of the nonlinearity functions contained in torch.nn.init . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . Default: None , and the weight tensor is initialized using torch.nn.ConvNd s default scheme. init_bias: None or str or callable ; Same as init_weight , but for the bias tensor. bias: bool ; If True , adds a learnable bias to the output. Default: True . **kw:dict ; Any additional KWargs are passed down to torch.nn.ConvNd , where N can be 1, 2 or 3. as well as warm.engine.forward . Refer to their docs for details. Some of the additional ConvNd arguments: stride, padding, dilation, groups . return: Tensor ; With shape (Batch, Size, *) where * can be 1d, 2d, 3d that depends on x .","title":"conv"},{"location":"reference/warm/functional/#dropout","text":"def : x , rate = 0.5 , by_channel = False , ** kw Dropout layer. During training, randomly zeros part of input tensor x , at probability rate . x: Tensor ; Can be of any shape if by_channel is false, or 2d and up if by_channel is true. rate: float ; The probability of dropout. Default 0.5. by_channel: bool ; If true, will dropout entire channels (all 'D' dimensions will be 0 if x is 'BCD' ). by_channel true requires x to be 2d or more. inplace: bool ; If true, the operation will be in-place and the input x will be altered. return: Tensor ; Same shape as x .","title":"dropout"},{"location":"reference/warm/functional/#gru","text":"def : * arg , ** kw Gated Recurrent Unit layer. x: Tensor ; 3d, with shapes (Batch, Channel, Length) . size: int ; Size of hidden features, and size of the output channel. init_weight_hh: None or str or callable ; Initialization specification for the hidden-hidden weight tensor. If a str , should be one of the nonlinearity functions contained in torch.nn.init . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . Default: 'orthogonal_' . init_weight_ih: None or str or callable ; Initialization specification for the input-hidden weight tensor. Default: None , and the weight tensor is initialized using torch.nn.GRU s default scheme. init_bias_hh: None or str or callable ; Initialization specification for the hidden-hidden bias tensor. Default: None , and the weight tensor is initialized using torch.nn.GRU s default scheme. init_bias_ih: None or str or callable ; Initialization specification for the input-hidden bias tensor. Default: None , and the weight tensor is initialized using torch.nn.GRU s default scheme. bias: bool ; If False , then the layer does not use bias_ih and bias_hh . Default: True . num_layers: int ; Number of the recurrent layers. Default: 1. tuple_out: bool ; If True , the returned value will be a tuple (out, (h_n, c_n)) . Default: False. **kw: dict ; Any additional KWargs are passed down to torch.nn.GRU , as well as warm.engine.forward . Refer to their docs for details. Some of the additional GRU arguments: dropout, bidirectional, batch_first . return: Tensor or tuple ; If tuple_out set to true, will return (out, (h_n, c_n) , otherwise just out . out has shape (Batch, Size, Length*Directions) , where Directions = 2 if bidirectional else 1. h_n is the hidden states with shape (num_layers*Directions, Batch, Size) . c_n is the cell states with shape (num_layers*Directions, Batch, Size) .","title":"gru"},{"location":"reference/warm/functional/#identity","text":"def : x , * arg , ** kw Identity layer that returns the first input, ignores the rest arguments.","title":"identity"},{"location":"reference/warm/functional/#linear","text":"def : x , size , init_weight = None , init_bias = None , bias = True , ** kw Linear transformation layer. x: Tensor ; 2d or more, with shapes (Batch, Channel, *) where * means any number of additional dimensions. size: int ; Size of hidden features, and size of the output channel. init_weight: None or str or callable ; Initialization specification for the weight tensor. If a str , should be one of the nonlinearity functions contained in torch.nn.init . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . Default: None , and the weight tensor is initialized using torch.nn.Linear s default scheme. init_bias: None or str or callable ; Same as init_weight , but for the bias tensor. bias: bool ; If True , adds a learnable bias to the output. Default: True . **kw:dict ; Any additional KWargs are passed down to warm.engine.forward . Refer to its docs for details. return: Tensor ; With shape (Batch, Size, *) where * can be 1d, 2d, 3d that depends on x .","title":"linear"},{"location":"reference/warm/functional/#lstm","text":"def : x , size , init_weight_hh = 'orthogonal_' , init_weight_ih = None , init_bias_hh = None , init_bias_ih = None , bias = True , num_layers = 1 , ** kw Long Short Term Memory layer. x: Tensor ; 3d, with shapes (Batch, Channel, Length) . size: int ; Size of hidden features, and size of the output channel. init_weight_hh: None or str or callable ; Initialization specification for the hidden-hidden weight tensor. If a str , should be one of the nonlinearity functions contained in torch.nn.init . If a callable , it will be applied to x directly, i.e. spec(x) . If a 2- tuple , it must be of format (callable, kwargs) , i.e. callable(x, **kwargs) . Default: 'orthogonal_' . init_weight_ih: None or str or callable ; Initialization specification for the input-hidden weight tensor. Default: None , and the weight tensor is initialized using torch.nn.LSTM s default scheme. init_bias_hh: None or str or callable ; Initialization specification for the hidden-hidden bias tensor. Default: None , and the weight tensor is initialized using torch.nn.LSTM s default scheme. init_bias_ih: None or str or callable ; Initialization specification for the input-hidden bias tensor. Default: None , and the weight tensor is initialized using torch.nn.LSTM s default scheme. bias: bool ; If False , then the layer does not use bias_ih and bias_hh . Default: True . num_layers: int ; Number of the recurrent layers. Default: 1. tuple_out: bool ; If True , the returned value will be a tuple (out, (h_n, c_n)) . Default: False. **kw: dict ; Any additional KWargs are passed down to torch.nn.LSTM , as well as warm.engine.forward . Refer to their docs for details. Some of the additional LSTM arguments: dropout, bidirectional, batch_first . return: Tensor or tuple ; If tuple_out set to true, will return (out, (h_n, c_n) , otherwise just out . out has shape (Batch, Size, Length*Directions) , where Directions = 2 if bidirectional else 1. h_n is the hidden states with shape (num_layers*Directions, Batch, Size) . c_n is the cell states with shape (num_layers*Directions, Batch, Size) .","title":"lstm"},{"location":"reference/warm/module/","text":"Module warm.module Custom modules to enhance the nn Sequential experience. Classes Lambda def : fn , * arg , ** kw Wraps a callable and all its call arguments. Ancestors (in MRO) torch.nn.modules.module.Module Methods forward def : self , x Forward will be perform at every call. Sequential def : * args Similar to nn.Sequential , except that child modules can have multiple outputs (e.g. nn.RNN ). Ancestors (in MRO) torch.nn.modules.container.Sequential torch.nn.modules.module.Module Descendants warm.module.Shortcut Methods forward def : self , x Forward will be perform at every call. Shortcut def : * arg , projection = None Similar to nn.Sequential , except that it performs a shortcut addition for the input and output. *arg: list of Modules ; Same as nn.Sequential . projection: None or callable ; If None , input with be added directly to the output. otherwise input will be passed to the projection first, usually to make the shapes match. Ancestors (in MRO) warm.module.Sequential torch.nn.modules.container.Sequential torch.nn.modules.module.Module","title":"Module"},{"location":"reference/warm/module/#module-warmmodule","text":"Custom modules to enhance the nn Sequential experience.","title":"Module warm.module"},{"location":"reference/warm/module/#classes","text":"","title":"Classes"},{"location":"reference/warm/module/#lambda","text":"def : fn , * arg , ** kw Wraps a callable and all its call arguments.","title":"Lambda"},{"location":"reference/warm/module/#ancestors-in-mro","text":"torch.nn.modules.module.Module","title":"Ancestors (in MRO)"},{"location":"reference/warm/module/#methods","text":"","title":"Methods"},{"location":"reference/warm/module/#forward","text":"def : self , x Forward will be perform at every call.","title":"forward"},{"location":"reference/warm/module/#sequential","text":"def : * args Similar to nn.Sequential , except that child modules can have multiple outputs (e.g. nn.RNN ).","title":"Sequential"},{"location":"reference/warm/module/#ancestors-in-mro_1","text":"torch.nn.modules.container.Sequential torch.nn.modules.module.Module","title":"Ancestors (in MRO)"},{"location":"reference/warm/module/#descendants","text":"warm.module.Shortcut","title":"Descendants"},{"location":"reference/warm/module/#methods_1","text":"","title":"Methods"},{"location":"reference/warm/module/#forward_1","text":"def : self , x Forward will be perform at every call.","title":"forward"},{"location":"reference/warm/module/#shortcut","text":"def : * arg , projection = None Similar to nn.Sequential , except that it performs a shortcut addition for the input and output. *arg: list of Modules ; Same as nn.Sequential . projection: None or callable ; If None , input with be added directly to the output. otherwise input will be passed to the projection first, usually to make the shapes match.","title":"Shortcut"},{"location":"reference/warm/module/#ancestors-in-mro_2","text":"warm.module.Sequential torch.nn.modules.container.Sequential torch.nn.modules.module.Module","title":"Ancestors (in MRO)"},{"location":"reference/warm/util/","text":"Module warm.util Short utilities. Functions camel_to_snake def : name Convert a camelCaseString to its snake_case_equivalent. summary def : model Print a summary about model buiding blocks and parameter counts.","title":"Util"},{"location":"reference/warm/util/#module-warmutil","text":"Short utilities.","title":"Module warm.util"},{"location":"reference/warm/util/#functions","text":"","title":"Functions"},{"location":"reference/warm/util/#camel_to_snake","text":"def : name Convert a camelCaseString to its snake_case_equivalent.","title":"camel_to_snake"},{"location":"reference/warm/util/#summary","text":"def : model Print a summary about model buiding blocks and parameter counts.","title":"summary"}]}